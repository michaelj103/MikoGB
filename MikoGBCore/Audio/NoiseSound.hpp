//
//  NoiseSound.hpp
//  MikoGBCore
//
//  Created by Michael Brandt on 2/26/22.
//  Copyright Â© 2022 Michael Brandt. All rights reserved.
//

#ifndef NoiseSound_hpp
#define NoiseSound_hpp

#include <cstdlib>

namespace MikoGB {

/// Models the state of the white noise generator (#4 of the GB's 4 sound circuits)
/// Told about writes to relevant memory offsets as they happen (mapped audio registers) and elapsed cycles
/// after every CPU step. Output is a sample which can be requested at any time, expected to be requested at 44100kHz
class NoiseSound {
public:
    void updateWithCycles(int cycles);
    
    // returns the value to store for future reads
    uint8_t soundWrite(uint16_t offset, uint8_t val);
    
    // volume is a value from -1.0 - 1.0
    double getSample() const;
    bool isRunning() const { return _isRunning; }

private:
    bool _isRunning = false;
    
    int _durationTime = 0; // initial duration CPU cycles
    int _durationCounter = 0; // remaining CPU cycles until sound ends
    bool _durationEnabled = false; // controlled by init and counter register
    void _resetDuration(uint8_t val);
    
    // envelope
    int _envelopeInitialVolume = 0; // initial envelope volume (0-15)
    int _envelopeVolume = 0; // current envelope volume (0-15)
    int _envelopeSign = 1; // +1 = amplify. -1 = attenuate
    int _envelopeStepTime = 0; // CPU cycles per envelope step
    int _envelopeStepCounter = 0; // remaining CPU cycles for the current envelope step
    void _resetEnvelope(uint8_t val);
    
    // frequency
    int _freqCycles = 0; // CPU cycles per LFSR shift
    int _freqCounter = 0; // remaining cycles before the next LFSR shift
    bool _lowBitMode = false; // is the LFSR in low bit mode (e.g. 7-bit)
    void _resetFrequency(uint8_t val);
    
    // init and counter
    void _resetInitAndCounter(uint8_t val);
    
    // Pseudo-random noise is generated by an LFSR in either 15- or 7-bit mode
    // The algorithm is: xor the low two bits, shift the whole register right
    // then put the xor result in the 14th bit (and 6th if in 7-bit mode)
    // 15/7 is convenient vs say 16/8 because if the register is any non-zero value,
    // then it will shift through all possible non-zero values in a random-looking order
    // if 16/8, there are several isolated "loops". Just can't start at 0
    uint16_t _lfsrRegister = 1;
    void _lfsrShift();
    
    void _initialize();
};

}

#endif /* NoiseSound_hpp */
